---
layout: post
title: "Epigrams in Programming"
modified:
categories: blog
excerpt:
tags: []
image:
  feature:
date: 2016-02-02T19:13:59+08:00
---

[http://www.cs.yale.edu/homes/perlis-alan/quotes.html](http://www.cs.yale.edu/homes/perlis-alan/quotes.html)

1. One man's constant is another man's variable.

	没有恒定，只有变化。

2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.

	函数推迟绑定，数据结构产生绑定。格言：在编程过程的后期再对数据进行结构化。

3. Syntactic sugar causes cancer of the semicolon.

	语法糖导致分号癌。

4. Every program is a part of some other program and rarely fits.

	每个程序都是其他程序的一部分，但是很少相互匹配。

5. If a program manipulates a large amount of data, it does so in a small number of ways.

	如果一个程序操作大量的数据，那么这种操作会在少量的步骤中完成。

6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.

	对称性会降低复杂度（协同程序包括子程序）；随处都要寻找对称性。

7. It is easier to write an incorrect program than understand a correct one.

	写错误的程序比理解正确的程序容易多了。

8. A programming language is low level when its programs require attention to the irrelevant.

	当使用一种语言所写的程序需要关注一些无关紧要的细节时，这种语言就是低级语言。

9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.

	用100个函数去操作1个数据结构比用10个函数去操作10个数据结构更好。

10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.



11. If you have a procedure with ten parameters, you probably missed some.

	如果程序有十个参数，你很可能会漏掉一些。

12. Recursion is the root of computation since it trades description for time.
	
	递归是计算的根本，因为它减少了描述的工作，从而节省了时间。

13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.

	如果两个人写出的代码一样，那么更细节的代码肯定不一样。

14. In the long run every program becomes rococo - then rubble.

	在长时间的运行每个程序都会变得脆弱 —— 继而出错。

15. Everything should be built top-down, except the first time.

	每件事都应该自顶向下进行，但是第一次要自底向上。

16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.

	每个程序都（至少）有两个目的：写这个程序的目的，非此目的的另一个目的。

17. If a listener nods his head when you're explaining your program, wake him up.

	如果在你解释程序的过程中有人点头，请叫醒他。

18. A program without a loop and a structured variable isn't worth writing.

	没有循环和结构化变量的程序不值得写。

19. A language that doesn't affect the way you think about programming, is not worth knowing.

	不能影响你编程思想的语言不值得了解。

20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.

	有模块化的地方就有可能导致误解：隐藏信息也意味着沟通成本。

21. Optimization hinders evolution.

	优化妨碍进化。

22. A good system can't have a weak command language.

	好的系统必须拥有一个强大的命令语言。

23. To understand a program you must become both the machine and the program.

	为了理解程序，你必须变成机器和程序。

24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.

	或许如果我们从小时候开始写程序，那么等我们成人后就可以能看懂它们了。

25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.

	一个人只能在头脑中展示复杂的信息。景色的欣赏、移动、流动或改变比静态的图片更重要，无论这张图片多么美丽。

26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.

	总有一些我们想在程序中表达，但在所有现有的语言中难以表达的思想。

27. Once you understand how to write a program get someone else to write it.

	一旦你理解了如何写程序，那么劝说其他人也开始写程序。

28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?

	在计算机领域，很难找到合适的时间单位来度量进度。一些大教堂需要一个世纪才能完工。你能想象需要这么长时间的程序会多么壮丽、庞大吗？

29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.

	对于系统来说，与面部拉皮同义的就是为控制图增加产生环状的边，而不是增加额外的节点。

30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.

	在编程中，我们做的每件事情都是另一些更普遍事情的特例 —— 通常我们很快会发现这个事实。

31. Simplicity does not precede complexity, but follows it.

	简洁性并非领先于复杂性，而是紧随其后。（深入浅出）

32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.

	并非以其创造性和逻辑来评判程序，而是要以其对各种情况分析的完整性来评判。

33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
	
	十诫是“可以计算”或“不可计算” —— 我忘了是哪句。

34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.

	字符串是一种单调的数据结构，它经过的地方都有大量重复的过程。它是一种隐藏信息的完美手段。

35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.

	每个人都可以被教授如何雕塑：米开朗基罗可能被教授不要去雕塑。So it is with great programmers. （什么意思？）

36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.

	用程序证明四色问题不会改变数学 —— 仅仅只是说明了这个世纪挑战，可能对数学一点都不重要。

37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.

	最重要的计算机就是在我们头颅内运转的，并且总是在寻找满意的外部仿真器。真正的计算机的标准化将是一个灾难 —— 所以可能永远不会发生。

38. Structured Programming supports the law of the excluded middle.

	结构化编程支持排中律。

39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.



40. There are two ways to write error-free programs; only the third one works.

	只有两种方式可以写出没有错误的程序；而只有第三种可行。

41. Some programming languages manage to absorb change, but withstand progress.

	某些编程语言能够吸收新的变化，但是却阻碍发展。

42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.

	

43. In software systems, it is often the early bird that makes the worm.

	在软件系统中，早起的鸟儿易生虫。

44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.

	有时我会认为计算机领域的唯一通用原则就是取指——执行循环。

45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.

	计算机学的目标是模仿我们的综合能力，而非理解分析能力。

46. Like punning, programming is a play on words.

	就像双关语，编程也是一种文字游戏。

47. As Will Rogers would have said, "There is no such thing as a free variable."

	Will Rogers可能会说，“天下没有免费的变量”。

48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.

	对于外行来说，最好的编程书籍是“爱丽丝漫游仙境”；但那是因为它对任何事情的外行来说都是最好的书。

49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.

	放弃汇编语言就是伊甸园中的苹果：浪费机器周期的语言的使用都是有罪的。LISP机器现在允许LISP程序员抛弃胸罩和无花果叶子。

50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.

	当我们理解了基于知识的系统时，系统仍旧如常——除了我们的指尖被烧焦了。

51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.

	将电脑带回家不会改变两者，但可能会使角落酒吧生意兴隆。

52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.

	系统包含子系统，子系统包含子系统，子子孙孙无穷尽也——这就是为何我们总是选择从头再来。

53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.

	一旦开始在语义的海湾扬帆远航，很多好点子都销声匿迹了。

54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.

	小心“Turing tar-pit”，对于它来说，任何事情都是可能的，但是想做事情却没那么容易。

55. A LISP programmer knows the value of everything, but the cost of nothing.

	LISP程序员了解每个事物的价值，但是不知道任何代价。

56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.

	软件总是处在一种矛盾状态。从象征性上来讲，随时可以说它已经完成了；但是又随时可能会变化。

57. It is easier to change the specification to fit the program than vice versa.

	修改文档容易，修改程序难。

58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.

	对于复杂性，蠢蛋忽略它，实用主义者忍受它，某些人可以避开它，天才会消除它。

59. In English every word can be verbed. Would that it were so in our programming languages.

	在英语中，每个词都可以动词化。在编程语言中也是这样吗。

60. In seeking the unattainable, simplicity only gets in the way.

	在寻找无法实现的过程中，只有简洁性会挡道。

61. In programming, as in everything else, to be in error is to be reborn.

	在编程中，如同其他事物，错误代表必须重生。

62. In computing, invariants are ephemeral.

	在计算机学中，不变是短暂的。

63. When we write programs that "learn", it turns out that we do and they don't.

	当我们写出具有“学习”能力的程序时，通常是我们学到了，而程序没有。

64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.

	通常为达手段，不择目的（这是一句反话，原话是“为达目的，不择手段”）：目标使得科技进步，即使目标已成泡影，科技既然存在。

65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.

	不要搞错了：计算机处理数字——而非字符。可以通过将某种活动代数化的程序来衡量我们的理解（和控制）。

66. Making something variable is easy. Controlling duration of constancy is the trick.

	使事情变化很容易。控制恒常的持续时间是关键。	

67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".

	想想所有耗费在寻找“算法”和“程序”根本区别的心理能量吧。

68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?

	如果我们相信数据结构，那么必须相信独立的（同时的）处理。如果不是这样，我们为何要把元素放到结构体里？为何我们会容忍塞给我们的语言，而不是其他语言？

69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.

	在5年时间内我们获得了一种优秀的编程语言。只是我们无法控制5年时间有多长。

70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.



71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.

	文档就像是定期寿险：因为订购它的人从来就没得到什么好处。

72. An adequate bootstrap is a contradiction in terms.

	足够的引导是自相矛盾的说法。

73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.

	能够控制变化速度不是语言的弱点而是其长处：唉，语言从来没有逃脱它的胚胎囊。

74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?

	软件不同于其他任何事物，其存在意味着被废弃：关键是将其看作一个肥皂泡，这种观点正确吗？

75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.

	因为朝气蓬勃，计算机领域总是极度缺乏陈词滥调：平庸会舒缓我们的神经。

76. It is the user who should parameterize procedures, not their creators.

	应该由用户来定义程序参数，而非写程序的人。

77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.

	人、计算机及算法的控制论交流就像是音乐椅游戏：对平衡的疯狂追求会使得三者其中之一忐忑不安。

78. If your computer speaks English, it was probably made in Japan.

	如果你的计算机可以说英文，那么可能是日本制造的。

79. A year spent in artificial intelligence is enough to make one believe in God.

	在人工智能领域工作一年就足以使人开始相信上帝。

80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.

	与计算机的长时间接触会把数学家变成书记员，反过来也成立。

81. In computing, turning the obvious into the useful is a living definition of the word "frustration".

	在计算领域，将显而易见变成有用的就是“挫折”的定义。

82. We are on the verge: Today our program proved Fermat's next-to-last theorem.

	我们正在接近：今天我们的程序证明了费马的下一个理论。

83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.

	图灵机和现代计算机之间的区别是什么？就如同希拉里攀登珠穆朗玛峰和在山顶上建立希尔顿酒店之间的区别。

84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.

	研究工作实验室的格言：我们今天所做的工作，其他人会首先想到明天。

85. Though the Chinese should adore APL, it's FORTRAN they put their money on.

	虽然中国人应该喜爱APL语言，但是他们只会为FORTRAN付钱。

86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.

	如果我们认为在一个活跃的数据库系统中，程序对数据的比率可以变得任意小或甚至保持很小，那么我们就是在欺骗自己。

87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?

	我们有迷你计算机和微型计算机。微微型计算机将会属于什么语义位置。

88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.

	麦克斯韦方程不足以设计电动机不是计算机的错误。

89. One does not learn computing by using a hand calculator, but one can forget arithmetic.

	人们无法通过使用手持计算器学会计算，但是可以忘记算术。

90. Computation has made the tree flower.

	计算使树开花。

91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.

	计算机让人想起朗·钱尼（演员，外号“千面人”） —— 它是一种千面机器。

92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.

	计算机是终极污染：它的粪便无法与产生的食物相区分。

93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.

	当某人说“我想要一种编程语言，借助它，我只需要说我想干什么就行了”时，给他一支棒棒糖。（对于编程语言的幼稚幻想）

94. Interfaces keep things tidy, but don't accelerate growth: Functions do.

	接口使得程序整洁，但不会加速其增长：这是函数要做的。

95. Don't have good ideas if you aren't willing to be responsible for them.

	如果你还没有将好点子付诸实践的决心时，就不要有好点子。

96. Computers don't introduce order anywhere as much as they expose opportunities.



97. When a professor insists computer science is X but not Y, have compassion for his graduate students.

	当一个教授坚持计算机科学是X而非Y时，对其研究生深表同情。（计算机是一门实践科学，概念上的这种咬文嚼字实在没有必要）

98. In computing, the mean time to failure keeps getting shorter.

	在计算机中，失败的平均时间正在持续缩短。

99. In man-machine symbiosis, it is man who must adjust: The machines can't.

	在人机共生中，人必须调整：机器无法做到。

100. We will never run out of things to program as long as there is a single program around.

	只有周围还有一个程序，那么我们就永远有可以编程的东西。

101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. c.

	处理失败很简单：努力改善。处理成功也很简单：解决了错误的问题。努力改善。

102. One can't proceed from the informal to the formal by formal means.

	一个人无法通过正规手段从不正规状态变为正规状态。

103. Purely applicative languages are poorly applicable.

	纯粹的应用性语言并不适用。

104. The proof of a system's value is its existence.

	系统价值的证据就是它的存在。（存在即价值）

105. You can't communicate complexity, only an awareness of it.

	你无法传达复杂性，只能意识到它。（比如有人给你说这事很复杂，但是对你来说是否复杂，只能你自己去体会）

106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.

	从字符串中提取有意义的信息很难，但是这是我们仅有的可以使用的沟通方式。

107. The debate rages on: is PL/I Bachtrian or Dromedary?

	这场辩论十分激烈：PL/I是双峰驼还是单峰驼？（啥意思啊？）

108. Whenever two programmers meet to criticize their programs, both are silent.

	当两个程序员一起评价他们的程序时，他们都会保持沉默。

109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.

	想想吧！用大规模集成电路（VLSI）可以在1平方厘米范围内集成100个ENIACS（世界上第一台计算机）。

110. Editing is a rewording activity.

	编辑是一种改写活动。

111. Why did the Roman Empire collapse? What is Latin for office automation?

	为何罗马帝国分崩离析？办公自动化的拉丁语怎么说来着？（即办公自动化导致了罗马帝国的分崩离析）

112. Computer Science is embarrassed by the computer.

	计算机使得计算机科学很尴尬。

113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.

	连接神经学和心理学的唯一建构理论会从软件研究中出现。

114. Within a computer natural language is unnatural.

	在计算机中，自然语言是非自然的。

115. Most people find the concept of programming obvious, but the doing impossible.

	许多人会很容易了解编程的概念，但几乎无法真正地去做。

116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.

	当你学习时，你会认为你知道了，当你写作时，你知道得更多，当你教授时，你甚至会知道更多，但当你编程时，你会确定知道了。

117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?

	现代教育教孩子编程违反常理。指定计划、在组织思想时遵守纪律、关注细节并学习自我批判有什么意思呢？

118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.

	如果你可以想象一个机器人地位很低的社会，那么你就可以想象任何事情。

119. Programming is an unnatural act.

	编程非自然行为。

120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.

	调整旧程序去适应新机器通常意味着将新机器调整得像旧机器。